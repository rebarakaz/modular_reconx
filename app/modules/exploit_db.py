"""
Local Exploit Database Module for Modular ReconX
Provides offline exploit database functionality similar to searchsploit
"""

import os
import json
import sqlite3
import logging
from typing import Dict, Any, List, Optional
from .utils import get_resource_path

logger = logging.getLogger(__name__)

# Path to the local exploit database
EXPLOIT_DB_PATH = get_resource_path("data/exploits.db")

def initialize_exploit_database() -> bool:
    """
    Initialize the local exploit database with basic schema.
    
    Returns:
        True if database was created or already exists, False on error
    """
    try:
        # Ensure data directory exists
        data_dir = os.path.dirname(EXPLOIT_DB_PATH)
        if data_dir and not os.path.exists(data_dir):
            os.makedirs(data_dir)
        
        # Create database and tables if they don't exist
        conn = sqlite3.connect(EXPLOIT_DB_PATH)
        cursor = conn.cursor()
        
        # Create exploits table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS exploits (
                id INTEGER PRIMARY KEY,
                exploit_id TEXT UNIQUE,
                title TEXT,
                description TEXT,
                platform TEXT,
                type TEXT,
                author TEXT,
                date_published TEXT,
                verified BOOLEAN,
                codes TEXT,
                tags TEXT,
                href TEXT
            )
        """)
        
        # Create index for faster searches
        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_exploits_platform ON exploits(platform)
        """)
        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_exploits_type ON exploits(type)
        """)
        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_exploits_tags ON exploits(tags)
        """)
        
        conn.commit()
        conn.close()
        logger.info("Exploit database initialized successfully")
        return True
    except Exception as e:
        logger.error(f"Failed to initialize exploit database: {e}")
        return False

def search_exploits_by_cve(cve_id: str) -> List[Dict[str, Any]]:
    """
    Search for exploits by CVE ID.
    
    Args:
        cve_id: CVE identifier (e.g., "CVE-2021-44228")
        
    Returns:
        List of matching exploits
    """
    if not os.path.exists(EXPLOIT_DB_PATH):
        initialize_exploit_database()
        return []
    
    try:
        conn = sqlite3.connect(EXPLOIT_DB_PATH)
        cursor = conn.cursor()
        
        # Search for exploits matching the CVE
        cursor.execute("""
            SELECT exploit_id, title, description, platform, type, author, 
                   date_published, verified, codes, tags, href
            FROM exploits 
            WHERE tags LIKE ? OR description LIKE ?
        """, (f"%{cve_id}%", f"%{cve_id}%"))
        
        results = cursor.fetchall()
        conn.close()
        
        exploits = []
        for row in results:
            exploits.append({
                "id": row[0],
                "title": row[1],
                "description": row[2],
                "platform": row[3],
                "type": row[4],
                "author": row[5],
                "date_published": row[6],
                "verified": bool(row[7]),
                "codes": row[8],
                "tags": row[9],
                "href": row[10],
                "source": "Local Exploit DB"
            })
        
        return exploits
    except Exception as e:
        logger.error(f"Error searching exploits by CVE {cve_id}: {e}")
        return []

def search_exploits_by_technology(tech_name: str, version: Optional[str] = None) -> List[Dict[str, Any]]:
    """
    Search for exploits by technology name and optional version.
    
    Args:
        tech_name: Technology name (e.g., "Apache", "WordPress")
        version: Optional version string (e.g., "2.4.49")
        
    Returns:
        List of matching exploits
    """
    if not os.path.exists(EXPLOIT_DB_PATH):
        initialize_exploit_database()
        return []
    
    try:
        conn = sqlite3.connect(EXPLOIT_DB_PATH)
        cursor = conn.cursor()
        
        # Build query based on whether version is provided
        if version:
            search_pattern = f"%{tech_name}%{version}%"
            cursor.execute("""
                SELECT exploit_id, title, description, platform, type, author, 
                       date_published, verified, codes, tags, href
                FROM exploits 
                WHERE (title LIKE ? OR description LIKE ? OR tags LIKE ?)
            """, (search_pattern, search_pattern, search_pattern))
        else:
            search_pattern = f"%{tech_name}%"
            cursor.execute("""
                SELECT exploit_id, title, description, platform, type, author, 
                       date_published, verified, codes, tags, href
                FROM exploits 
                WHERE (title LIKE ? OR description LIKE ? OR tags LIKE ?)
            """, (search_pattern, search_pattern, search_pattern))
        
        results = cursor.fetchall()
        conn.close()
        
        exploits = []
        for row in results:
            exploits.append({
                "id": row[0],
                "title": row[1],
                "description": row[2],
                "platform": row[3],
                "type": row[4],
                "author": row[5],
                "date_published": row[6],
                "verified": bool(row[7]),
                "codes": row[8],
                "tags": row[9],
                "href": row[10],
                "source": "Local Exploit DB"
            })
        
        return exploits
    except Exception as e:
        logger.error(f"Error searching exploits for {tech_name}: {e}")
        return []

def search_exploits_by_platform(platform: str) -> List[Dict[str, Any]]:
    """
    Search for exploits by platform.
    
    Args:
        platform: Platform name (e.g., "linux", "windows", "multiple")
        
    Returns:
        List of matching exploits
    """
    if not os.path.exists(EXPLOIT_DB_PATH):
        initialize_exploit_database()
        return []
    
    try:
        conn = sqlite3.connect(EXPLOIT_DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT exploit_id, title, description, platform, type, author, 
                   date_published, verified, codes, tags, href
            FROM exploits 
            WHERE platform = ?
        """, (platform.lower(),))
        
        results = cursor.fetchall()
        conn.close()
        
        exploits = []
        for row in results:
            exploits.append({
                "id": row[0],
                "title": row[1],
                "description": row[2],
                "platform": row[3],
                "type": row[4],
                "author": row[5],
                "date_published": row[6],
                "verified": bool(row[7]),
                "codes": row[8],
                "tags": row[9],
                "href": row[10],
                "source": "Local Exploit DB"
            })
        
        return exploits
    except Exception as e:
        logger.error(f"Error searching exploits by platform {platform}: {e}")
        return []

def get_exploit_details(exploit_id: str) -> Optional[Dict[str, Any]]:
    """
    Get detailed information about a specific exploit.
    
    Args:
        exploit_id: Exploit identifier
        
    Returns:
        Exploit details or None if not found
    """
    if not os.path.exists(EXPLOIT_DB_PATH):
        initialize_exploit_database()
        return None
    
    try:
        conn = sqlite3.connect(EXPLOIT_DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT exploit_id, title, description, platform, type, author, 
                   date_published, verified, codes, tags, href
            FROM exploits 
            WHERE exploit_id = ?
        """, (exploit_id,))
        
        row = cursor.fetchone()
        conn.close()
        
        if row:
            return {
                "id": row[0],
                "title": row[1],
                "description": row[2],
                "platform": row[3],
                "type": row[4],
                "author": row[5],
                "date_published": row[6],
                "verified": bool(row[7]),
                "codes": row[8],
                "tags": row[9],
                "href": row[10],
                "source": "Local Exploit DB"
            }
        
        return None
    except Exception as e:
        logger.error(f"Error getting exploit details for {exploit_id}: {e}")
        return None

def update_exploit_database(exploit_data: List[Dict[str, Any]]) -> bool:
    """
    Update the local exploit database with new exploit data.
    
    Args:
        exploit_data: List of exploit dictionaries to add/update
        
    Returns:
        True if update was successful, False otherwise
    """
    try:
        if not os.path.exists(EXPLOIT_DB_PATH):
            initialize_exploit_database()
        
        conn = sqlite3.connect(EXPLOIT_DB_PATH)
        cursor = conn.cursor()
        
        # Insert or update exploits
        for exploit in exploit_data:
            cursor.execute("""
                INSERT OR REPLACE INTO exploits 
                (exploit_id, title, description, platform, type, author, 
                 date_published, verified, codes, tags, href)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                exploit.get("id", ""),
                exploit.get("title", ""),
                exploit.get("description", ""),
                exploit.get("platform", ""),
                exploit.get("type", ""),
                exploit.get("author", ""),
                exploit.get("date_published", ""),
                int(exploit.get("verified", False)),
                exploit.get("codes", ""),
                exploit.get("tags", ""),
                exploit.get("href", "")
            ))
        
        conn.commit()
        conn.close()
        logger.info(f"Updated exploit database with {len(exploit_data)} entries")
        return True
    except Exception as e:
        logger.error(f"Failed to update exploit database: {e}")
        return False